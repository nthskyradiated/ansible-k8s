---
- name: Initialize control plane list
  set_fact:
    cp: []

- name: Build control plane list
  set_fact:
    cp: "{{ cp + [ { 'name': 'controlplane%02d'|format(item), 'memory': 4096, 'vcpus': 2, 'disk_size': 20, 'os_variant': 'ubuntu24.04', 'ip': '192.168.100.%d'|format(210 + item) } ] }}"
  loop: "{{ range(1, (control_planes|int) + 1) | list }}"

- name: Initialize worker node list
  set_fact:
    wn: []

- name: Build worker node list
  set_fact:
    wn: "{{ wn + [ { 'name': 'node%02d'|format(item), 'memory': 4096, 'vcpus': 2, 'disk_size': 20, 'os_variant': 'ubuntu24.04', 'ip': '192.168.100.%d'|format(220 + item) } ] }}"
  loop: "{{ range(1, (worker_nodes|int) + 1) | list }}"

- name: Build loadbalancer list if needed
  set_fact:
    lb: "{{ [ { 'name': 'loadbalancer', 'memory': 2048, 'vcpus': 1, 'disk_size': 20, 'os_variant': 'ubuntu24.04', 'ip': '192.168.100.200' } ] if (control_planes|int) > 1 else [] }}"

- name: Combine all VM definitions
  set_fact:
    vms: "{{ cp + wn + lb }}"

- name: Install required packages (Debian/Ubuntu)
  ansible.builtin.apt:
    name:
      - cloud-image-utils
      - cloud-utils
      - qemu-utils
      - qemu-system-x86
      - qemu-kvm
      - libvirt-daemon-system
      - libvirt-clients
    state: present
    update_cache: yes
  become: true
  when: ansible_os_family == "Debian"

- name: Enable EPEL Repository (RedHat/Fedora)
  ansible.builtin.dnf:
    name: epel-release
    state: present
  become: true
  when: ansible_os_family == "RedHat"

- name: Install required packages (RedHat/Fedora)
  ansible.builtin.dnf:
    name:
      - cloud-init
      - cloud-utils-growpart
      - genisoimage
      - qemu-img
      - qemu-kvm
      - qemu-kvm-core
      - libvirt
      - libvirt-client
      - libvirt-daemon
      - libvirt-daemon-driver-qemu
      - libguestfs-tools
      - virt-install
    state: present
  become: true
  when: ansible_os_family == "RedHat"

- name: Set QEMU emulator path based on OS
  set_fact:
    qemu_emulator_path: "{{ '/usr/libexec/qemu-kvm' if ansible_os_family == 'RedHat' else '/usr/bin/kvm' }}"

- name: Download Ubuntu cloud image
  ansible.builtin.get_url:
    url: "https://cloud-images.ubuntu.com/noble/current/noble-server-cloudimg-amd64.img"
    dest: "/var/lib/libvirt/images/ubuntu-base.qcow2"
    mode: '0644'
  become: true

- name: Create base disk images for VMs
  ansible.builtin.command: "qemu-img create -f qcow2 -F qcow2 -b /var/lib/libvirt/images/ubuntu-base.qcow2 /var/lib/libvirt/images/{{ item.name }}.qcow2 {{ item.disk_size }}G"
  args:
    creates: "/var/lib/libvirt/images/{{ item.name }}.qcow2"
  become: true
  loop: "{{ vms }}"

- name: Create cloud-init configs for each VM
  ansible.builtin.template:
    src: "{{ item[0] }}.j2"
    dest: "/var/lib/libvirt/images/{{ item[1].name }}-{{ item[0] }}"
    mode: '0644'
  become: true
  with_nested:
    - ['meta-data', 'user-data', 'network-config']
    - "{{ vms }}"
  loop_control:
    loop_var: item

- name: Generate cloud-init ISOs for VMs
  ansible.builtin.shell: |
    cd /var/lib/libvirt/images && \
    genisoimage -output {{ item.name }}-cloud-init.iso \
      -volid cidata -joliet -rock -input-charset utf-8 \
      {{ item.name }}-meta-data {{ item.name }}-user-data {{ item.name }}-network-config
  args:
    creates: "/var/lib/libvirt/images/{{ item.name }}-cloud-init.iso"
  become: true
  loop: "{{ vms }}"

- name: Get list of active networks
  ansible.builtin.shell: "virsh net-list --all | grep -E '^\ +.*running' | awk '{print $1}'"
  register: active_networks
  changed_when: false

- name: Get list of inactive networks
  ansible.builtin.shell: "virsh net-list --all | grep -E '^\ +.*inactive' | awk '{print $1}'"
  register: inactive_networks
  changed_when: false

- name: Stop active networks
  ansible.builtin.command: "virsh net-destroy {{ item }}"
  with_items: "{{ active_networks.stdout_lines }}"
  ignore_errors: true
  become: true

- name: Undefine all networks
  ansible.builtin.command: "virsh net-undefine {{ item }}"
  with_items: "{{ active_networks.stdout_lines + inactive_networks.stdout_lines }}"
  ignore_errors: true
  become: true

- name: Create and start k8s network
  block:
    - name: Define k8s network
      ansible.builtin.shell: |
        virsh net-define /dev/stdin <<EOF
        <network>
          <name>k8s-net</name>
          <bridge name='k8sbr0'/>
          <forward mode='nat'/>
          <ip address='192.168.100.1' netmask='255.255.255.0'>
          </ip>
        </network>
        EOF
      become: true

    - name: Start k8s network
      ansible.builtin.command: "virsh net-start k8s-net"
      become: true

    - name: Enable autostart for k8s network
      ansible.builtin.command: "virsh net-autostart k8s-net"
      become: true
  rescue:
    - name: Cleanup and retry network setup
      block:
        - name: Force destroy k8s network
          ansible.builtin.shell: |
            virsh net-destroy k8s-net || true
            virsh net-undefine k8s-net || true
          become: true
        
        - name: Retry network creation
          ansible.builtin.shell: |
            virsh net-define /dev/stdin <<EOF
            <network>
              <name>k8s-net</name>
              <bridge name='k8sbr0'/>
              <forward mode='nat'/>
              <ip address='192.168.100.1' netmask='255.255.255.0'>
              </ip>
            </network>
            EOF
            virsh net-start k8s-net
            virsh net-autostart k8s-net
          become: true

- name: Get supported machine types
  ansible.builtin.shell: "qemu-system-x86_64 -machine help | grep pc-q35 | head -n1 | awk '{print $1}'"
  register: machine_type
  changed_when: false

- name: Define VMs using virsh
  ansible.builtin.shell: |
    virsh define /dev/stdin <<EOF
    <domain type='kvm'>
      <name>{{ item.name }}</name>
      <memory unit='MiB'>{{ item.memory }}</memory>
      <vcpu>{{ item.vcpus }}</vcpu>
      <os>
        <type arch='x86_64'>hvm</type>
        <boot dev='hd'/>
      </os>
      <features>
        <acpi/>
        <apic/>
      </features>
      <cpu mode='host-model'/>
      <devices>
        <emulator>{{ qemu_emulator_path }}</emulator>
        <disk type='file' device='disk'>
          <driver name='qemu' type='qcow2'/>
          <source file='/var/lib/libvirt/images/{{ item.name }}.qcow2'/>
          <target dev='vda' bus='virtio'/>
        </disk>
        <disk type='file' device='cdrom'>
          <driver name='qemu' type='raw'/>
          <source file='/var/lib/libvirt/images/{{ item.name }}-cloud-init.iso'/>
          <target dev='sda' bus='sata'/>
          <readonly/>
        </disk>
        <interface type='network'>
          <mac address='52:54:00:{{ item.name | hash('md5') | truncate(2, True, '') }}:{{ item.name | hash('sha1') | truncate(2, True, '') }}:{{ item.ip | hash('md5') | truncate(2, True, '') }}'/>
          <source network='k8s-net'/>
          <model type='virtio'/>
        </interface>
        <serial type='pty'/>
        <console type='pty'/>
      </devices>
    </domain>
    EOF
  become: true
  loop: "{{ vms }}"

- name: Start VMs using virsh
  ansible.builtin.command: "virsh start {{ item.name }}"
  become: true
  loop: "{{ vms }}"
  ignore_errors: true  # In case VM is already running

- name: Wait for VMs to boot
  ansible.builtin.pause:
    seconds: 30

- name: Get VM IP addresses
  ansible.builtin.shell: "virsh domifaddr {{ item.name }}"
  register: vm_ips
  loop: "{{ vms }}"
  become: true

- name: Display VM network info
  ansible.builtin.debug:
    var: vm_ips

- name: Check cloud-init status
  ansible.builtin.shell: |
    virsh qemu-agent-command {{ item.name }} '{"execute":"guest-exec","arguments":{"path":"/usr/bin/cloud-init","arg":["status"]}}' || true
  register: cloud_init_status
  loop: "{{ vms }}"
  become: true
  ignore_errors: true

- name: Display cloud-init status
  ansible.builtin.debug:
    var: cloud_init_status

- name: Wait for VMs to be accessible
  wait_for:
    host: "{{ item.ip }}"
    port: 22
    timeout: 300
  loop: "{{ vms }}"

- name: Set host naming on provisioned VMs
  ansible.builtin.command: "hostnamectl set-hostname {{ item.name }}"
  delegate_to: "{{ item.name }}"
  loop: "{{ vms }}"
  when: vms is defined
  ignore_unreachable: yes
  ignore_errors: yes
